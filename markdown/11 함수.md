## 11 함수

### 함수란?

- 입력을 받아서 출력을 내보내는 것이다.
- 입력을 받은 값을 어떻게 처리할지 일련의 과정을 문들로 구현하고 코드 블록으로 감싸서 **하나의 실행 단위로 정의**한 것이다.
- 입력을 전달받은 변수를 **매개변수**, 입력을 **인수**, 출력을 **반환값**이라고 한다.
- 함수는 **정의를 통해 생성되고 호출을 통해 실행**된다.

### 함수의 사용 이유

- 함수는 필요할 때 사용할 수 있으므로 **코드의 재사용** 측면에서 매우 유용하다.
- 유지보스의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높일 수 있다.
- 함수도 변수와 마찬가지로 식별자를 정할 때 역할을 잘 설명하여 코드의 가독성을 향상시킬 수 있다.

### 함수 리터럴

함수도 리터럴로 선언될 수 있는데 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다. 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체이다. 즉 함수는 객체라고 할 수 있다.

- 함수 이름
  - 함수의 이름또한 식별자이다. 식별자 네이밍 규칙을 준수해야 한다.
  - 함수의 이름은 생략할 수 있다. 함수 이름이 있는 함수를 **기명 함수**, 없는 함수를 **익명 함수**라 한다.
- 매개변수 목록
  - 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다. 이 변수에는 인수가 할당된다.
  - 매개변수 또한 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.
- 함수 몸체
  - 호출에 의해 실행되는 것이다. 일괄적으로 실행되는 단위의 코드블록이다.

### 함수 정의

- 함수 선언문 : 리터럴 표기법과 동일한 형태이며, 함수 이름을 생략할 수 없다.

  ```javascript
  function add(x, y){
      return x + y;
  }
  ```

  - 자바스크립트 엔진은 암묵적으로 함수 이름을 식별자로 가진 변수를 만들고 그 변수를 호출하여 함수를 실행한다.

    ```javascript
    var add = function add(x, y){
        return x + y;
    }
    ```

- 함수 표현식 : 함수는 객체이므로 변수에 함수를 할당할 수 있다.

  ```javascript
  var add = function (x, y) {
      return x + y;
  }
  ```

- 함수 생성 시점과 함수 호이스팅 : 함수 선언문으로 생성한 함수는 호이스팅 되어 먼저 실행된다. 함수 표현식으로 사용한 변수 할당문도 호이스팅되지만, 할당은 런타임때 실행되므로 undefined, TypeError가 발생한다.

  ```javascript
  // 함수 참조
  console.dir(add); // ƒ add(x, y)
  console.dir(sub); // undefined

  // 함수 호출
  console.log(add(2, 5)); // 7
  console.log(sub(2, 5)); // TypeError: sub is not a function

  // 함수 선언문
  function add(x, y) {
    return x + y;
  }

  // 함수 표현식
  var sub = function (x, y) {
    return x - y;
  };
  ```

  - 함수 호이스팅은 코드의 구조를 엉성하게 만들 수 있다. 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권장하고 있다.

- Function 생성자 함수 : 이 방식으로 함수를 생성하면 '클로저'를 생성하지 않아서, 위의 방법들과 동일하게 동작하지 않는다. 잘 사용하진 않지만 주의하여야 한다.

  ```javascript
  var add = new Function('x', 'y', 'return x + y');

  console.log(add(2, 5)); // 7
  ```

- 화살표 함수 : ES6에서 키워드 대신 화살표를 사용하여 더 간략하게 함수를 선언할 수 있는 방법이다.

  ```javascript
  const add = (x, y) => x + y;
  ```

  - 기존 선언문, 표현식을 완전히 대체하기 위해 디자인된 것은 아니다. 기존 함수와 this방식이 다르고 prototype 프로퍼티가 없고, arguments 객체를 생성하지 않는다.

### 함수 호출

- 함수를 참조하는 변수와 호출 연산자인 소괄호를 이용하여 호출한다. 소괄호 연산자 내에는 0개 이상의 인수를 쉼표로 구분하여 나열한다.

### 매개변수와 인수

- 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 변수와 마찬가지로 undefiend로 초기화된 후 인수가 할당된다.
- 매개변수의 스코프(유효 범위)는 함수 내부이다.
- 매개변수에 비해 인수가 부족할 경우 undefined값이 저장되어 계산된다. 인수가 많을경우 초과된 인수는 무시된다.
  - 초과되어 무시된 인수를 포함한 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

### 인수 확인

- 자바스크립트는 동적타입의 언어로 매개변수의 타입을 사전에 지정하지 않는다. 따라서 직접 조건문을 통해 적절한 인수가 전달되었는지 확인이 필요하다.

  ```javascript
  var add = function (x, y){
      if (typeof x !== 'number' || typeof y !== 'number'){
          throw new TypeError('에러 메세지');
      }
      return x + y;
  }
  ```

### 매개변수의 개수

- 이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 한다. 따라서 매개변수의 개수는 적을수록 좋고, 최대 3개 이상을 넘지 않는것을 권장한다.
- 많은 매개변수가 필요하다면, 매개변수 객체를 선언하고 객체를 인수로 전달받아서 해결할 수 있다. (pass by reference됨을 주의하자.)

### 외부 상태의 변경과 함수형 프로그래밍

- 외부 상태를 변경시키는 효과가 있는 함수를 비순수 함수라고 부른다. 함수형 프로그래밍은 순수 함수를 통해 부수효과를 최대한 억제하여 프로그래밍을 하는 방법이다.
  - pass by value : 원시값을 전달할 때 사용하는 방법이고 값 자체를 복사한다. 원시값 자체를 건드리진 않는다.
  - pass by reference : 객체를 전달할 때 사용하는 방법이다. 참조하는 주소값이 복사되기 때문에 객체 자체를 건드리게 된다.

### 반환문

- 함수는 return 키워드를 사용하여 값을 반환한다. 함수 호출은 표현식인데, 이는 return으로 받은 반환값을 평가한다.
- return 키워드 밑의 문은 실행되지 않는다. 반환값을 입력하지 않으면 undefined가 반환된다.
- return은 생략될 수 있으며, 생략 될 경우 undefined를 반환한다.
- return 문에 줄바꿈이 일어나면 세미콜론이 자동으로 추가되므로, return문이 길면 중괄호로 묶어주어야 한다.

### 다양한 함수의 형태

- 즉시실행함수 : 함수 정의 마지막에 ()를 입력하여 함수를 즉시 실행할 수 있다. 즉시 실행함수는 한번만 호출되며 다시 호출할 수 없다. IIFE라고 부른다.
  - **즉시 실행 함수는 전역변수를 없애는 가장 편한 방법으로 굉장히 중요하다.**
  ```javascript
  var res = (function () {
    var a = 3;
    var b = 5;
    return a * b;
  }());

  console.log(res); // 15

  res = (function (a, b) {
    return a * b;
  }(3, 5));

  console.log(res); // 15
  ```

- 재귀 함수 : 자기 자신을 호출하는 함수를 말한다. 대부분의 재귀 함수는 for문이나 while문으로 구현할 수 있고, 재귀함수는 반복문을 사용하는 것 보다 재귀함수를 사용하는 것이 직관적으로 이해하기 쉬울 때 사용하는 것이 바람직하다.

  ```javascript
  function factorial(n) {
    // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
    if (n <= 1) return 1;
    return factorial(n - 1) * n;
  }
  ```

- 중첩 함수 : 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수라고 한다. 중첩함수는 외부함수에 접근할 수 있어서 헬퍼함수라고도 부른다. 외부 함수는 중첩함수에 접근할 수 없다.

- 콜백 함수 : 인수로 들어가는 함수를 **콜백함수** 받는 함수를 **고차함수** 라고 부른다.

  - 콜백함수도 외부함수의 역할을 돕는 헬퍼함수인데, 중첩함수는 내부에 고정되어 있는 반면, 콜백함수는 외부에서 인수로 주입하기 때문에 자유롭다는 장점이 있다.
  - 반복된 동작을 하는 고차함수를 만들고, 세분화된 동작을 콜백함수로 만들어서 유용하게 사용할 수 있다.