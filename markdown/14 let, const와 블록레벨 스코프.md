## 전역 변수의 문제점

### 변수의 생명 주기

- 지역 변수의 생명 주기
  - 함수가 호출되면 생성되고, 함수가 종료되면 소멸한다.
  - **변수 호이스팅 또한 그 지역 내에서만 호이스팅 된다.**
- 전역 변수의 생명 주기
  - 전역변수는 코드를 실행하면 바로 생성된다. 브라우저 환경에서 var로 선언된 전역 변수는 웹 페이지가 종료할 때 까지 유효하게 된다.

### 전역 변수의 문제점

- 모든 코드가 변수를 참조하고 변경할 수 있다. 이를 **암묵적 결합**이라고 한다.
  - 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고, 암묵적 결합에 의해 의도치 않게 상태가 변경될 수 있는 위험성도 높다.
- 전역 변수는 **생명주기가 길다**. 즉 상태가 변경될 확률이 높고, 그로 인해 오류가 발생될 확률도 높다. 메모리 리소스도 많이 소비하게 된다.
- 변수를 참조할 때 스코프 체인을 따라가는데, 전역변수는 가장 마지막에 존재한다. 즉 **전역 변수의 검색속도는 가장 느리다.**
- 자바스크립트의 특성상 파일이 분리되어 있어도 **하나의 전역스코프를 공유**한다. 동일한 이름으로 명명된 변수나 함수가 존재할 경우 위험하다.

### 전역 변수 사용 억제 방법

- 즉시 실행 함수
  - 함수의 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다. **모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 지역 변수가 된다.**
  - 이 방법은 라이브러리 등에 자주 사용된다.
- 네임 스페이스 객체
  - 객체를 만들어서 네임 스페이스를 분리할 수 있다. 충돌을 방지할 수 있지만, 네임스페이스 객체 자체가 전역변수에 할당되므로 그리 유용하지 않다.
- 모듈 패턴
  - 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸서 하나의 모듈을 만든다. 클로저를 기반으로 동작한다.
  - 모듈 패턴은 전역 변수를 억제하는 것은 물론, 캡슐화까지 구현할 수 있다. 캡슐화는 외부에 공개하기 싫은 변수를 내부에서 보호하는 기능을 의미한다.
- ES6 모듈
  - ES6에서 도입된 모듈을 사용하여 억제할 수 있지만, 대부분의 브라우저가 완전히 지원하지는 않고 있다.

## let, const와 블록 레벨 스코프

### var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 허용

  - 변수가 중복선언 되었을 때, 오류를 발생시키지 않고 var 키워드가 없는 것 처럼 동작한다/

  - 만약 동일한 변수 이름이 선언된 것을 모르고 중복 선언한다면, 의도치 않게 먼저 선언된 변수값이 변경되는 부작용이 발생한다.

    ```javascript
    var x = 1;
    var x = 100; //오류가 발생하지 않음.
    ```

- 함수 레벨 스코프

  - var는 블록 레벨 스코프가 아닌 함수 레벨 스코프를 인정하기 때문에 의도치 않게 전역변수를 남발하게 된다.
  - for, if 문 등에서 사용한 변수도 모두 전역변수가 되어버림을 주의하여야 한다.

- 변수 호이스팅

  - 변수의 참조가 변수의 선언보다 먼저 나와도 호이스팅 되어 참조할 수 있다. 이는 프로그램의 흐름 상 맞지 않고, 가독성을 떨어트리며 오류를 발생시킬 여지를 남긴다.

### let 키워드

앞서 말한 var 키워드의 단점을 보완하기 위해 ES6에서 변수를 선언하는 let과 const 키워드가 도입되었다.

- 변수 중복 선언 금지

  - let 키워드는 변수가 중복선언되면 SyntaxError가 발생한다.

- 블록 레벨 스코프

  - 블록으로 묶인 공간에서만 스코프를 가진다.

- 변수 호이스팅

  - let 키워드도 호이스팅이 되지만 var과는 다르게 동작한다. var 변수가 호이스팅 되어 선언과 undefined로 초기화가 한번에 진행됬다면, let 변수는 선언만 진행한다.

    ```javascript
    let foo = 1; // 전역 변수

    {
      console.log(foo); // ReferenceError: foo is not defined
      let foo = 2; // 지역 변수
    }
    ```

    - 호이스팅이 아예 안된다면 전역변수를 출력해야 하지만 선언은 호이스팅 되었다는 것을 보여준다.

  - 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 **일시적 사각지대** 라고 부른다.

- 전역 객체와 let

  - 전역 객체는 가장 먼저 생성되며, 어떤 객체에도 속하지 않은 최상위 객체이다. 일반적으로 브라우저 환경에서는 window 객체, Node.js 환경에서는 global 객체이다.

  - var 키워드로 변수를 선언하게 되면 위 전역 객체의 프로퍼티가 되는 것이다.

    ```javascript
    var x = 1;
    console.log(window.x); // 1
    ```

  - 하지만 let으로 선언한 전역 변수는 **보이지 않는 개념적인 블록**내에 존재한다.

### const 키워드

const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하는 것은 아니다.

- 선언과 초기화
  - const키워드는 재할당을 할 수 없다. 즉 const 키워드로 선언한 변수는 선언과 할당이 동시에 이루어져야 한다. 그렇지 않으면 SyntaxError가 발생한다.
  - let과 마찬가지로 블록 레벨 스코프를 가진다.
- 상수
  - 상수에는 프로그램 전체에서 고정된 값을 사용해야 한다. 가독성과 유지보수의 편의를 높여줄 수 있으므로, 필요할 때는 적극적으로 사용한다.
  - 상수는 변수 이름을 대문자로 선언하고, 여러 단어로 이루어진 경우 _로 구분하여 상수를 저장하고 있음을 명확히 나타내는 것이 일반적이다.

- const 키워드와 객체
  - 객체를 const 키워드로 선언해도 객체는 변경이 가능하다. const 키워드는 재할당을 금지할 뿐, 불변을 의미하지는 않는다.

### var vs. let vs. const

- 변수의 선언에는 기본적으로 const를 사용하고, 재할당이 필요할 경우 한정적으로만 let을 사용하는 것이 좋다.
- 객체를 재할당 하는 경우는 흔치않다. const를 사용해서 재할당을 방지해주자.
- ES6를 사용한다면 var 키워드는 사용하지 않는 것이 좋고, 변수들의 스코프는 최대한 좁게 만든다.
- 생각보다 변수를 재할당 하는 경우는 드물다. 변수가 필요할 경우 const 키워드를 주로 사용하고, 코드를 작성하다가 반드시 재할당이 필요하다면 let으로 키워드를 변경해도 늦지 않다.